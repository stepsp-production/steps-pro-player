<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Steps Production Co Player</title>

  <!-- Players -->
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
  <script src="https://www.youtube.com/iframe_api"></script>
  <script src="https://player.vimeo.com/api/player.js"></script>

  <!-- أيقونة -->
  <link rel="icon"
        href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%230b0b0f'/%3E%3Cpolygon points='26,20 26,44 46,32' fill='%23e53935'/%3E%3C/svg%3E" />

  <!-- تهيئة شبكة -->
  <link rel="preconnect" href="https://stream.mux.com" crossorigin>
  <link rel="preload" as="fetch" href="https://stream.mux.com/jIy7RfNkNJqkZ1008eyc01WH9i4Nh37Q001xqZEdA50000LI.m3u8" crossorigin>

  <style>
    :root{--btn-bg:#e53935;--btn-bg-h:#d32f2f;--btn-bg-a:#b71c1c;--btn-txt:#fff;--btn-ring:rgba(211,47,47,.28);--panel-bg:#0b0b0fbb;--panel-bd:#ffffff26}
    *{box-sizing:border-box} html,body{height:100%} body{margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #playerContainer{position:relative;width:100vw;height:100vh}
    .videoFrame{position:absolute;top:0;right:0;width:100%;height:100%;background:#000;overflow:hidden}
    #freezeLayer{position:absolute;inset:0;z-index:5;pointer-events:none;opacity:0;transition:opacity .18s}
    #mainPreview{position:absolute;top:16px;right:20px;width:22%;height:24%;z-index:6;border:1px solid #fff2;border-radius:18px;cursor:pointer;transition:transform .18s,box-shadow .18s,width .18s,height .18s,top .18s,right .18s,left .18s}
    #mainPreview:hover{box-shadow:0 10px 30px #0008}
    #mainPreview video{display:block;width:100%;height:100%;object-fit:contain}
    .split #mainPreview{top:0;right:0;width:50%;height:100%;border:0;border-radius:0;cursor:default}
    .split #activeCam{top:0;left:0;right:auto;width:50%;height:100%}
    .split.fill #mainPreview video,.split.fill #activeCam video{object-fit:cover}
    .main-full #mainPreview{top:0;right:0;width:100%;height:100%;z-index:7;border:0;border-radius:0;cursor:zoom-out}
    .main-full #activeCam{display:none}
    .hint{position:absolute;top:20px;right:20px;z-index:8;background:#000a;color:#fff;padding:6px 10px;border-radius:999px;font-size:12px;border:1px solid #fff2}
    .split .hint,.main-full .hint{display:none}
    #utilityControls,#camControls,#globalControls{position:absolute;z-index:10;display:flex;gap:8px;flex-wrap:wrap;transition:top .18s,left .18s,right .18s}
    #utilityControls{background:transparent;padding:0;border:0;border-radius:12px}
    #utilityControls.vertical{flex-direction:column} #utilityControls.horizontal{flex-direction:row}
    #utilityControls .group{display:flex;gap:6px;align-items:center}
    .divider{width:1px;height:22px;background:var(--panel-bd);border-radius:2px;margin:0 4px}
    #globalControls{bottom:70px;left:50%;transform:translateX(-50%);background:var(--panel-bg);padding:10px;border-radius:14px;border:1px solid var(--panel-bd);backdrop-filter:blur(8px);align-items:center;min-width:320px}
    #globalControls.hidden{display:none}
    #scrub{-webkit-appearance:none;appearance:none;width:320px;height:6px;border-radius:999px;background:#ffffff30;outline:none;margin:0 8px}
    #scrub::-webkit-slider-thumb{-webkit-appearance:none;width:14px;height:14px;border-radius:50%;background:#fff;border:2px solid #0006;cursor:pointer}
    #timeLabel{color:#fff;font-size:12px;min-width:108px;text-align:center}
    #camControls{bottom:14px;left:50%;transform:translateX(-50%);background:var(--panel-bg);padding:10px;border-radius:14px;border:1px solid var(--panel-bd);backdrop-filter:blur(8px)}
    button{-webkit-tap-highlight-color:transparent;appearance:none;border:0;outline:0;cursor:pointer;background:var(--btn-bg);color:var(--btn-txt);padding:11px 12px;font-size:12px;line-height:1;font-weight:800;border-radius:12px;letter-spacing:.2px;min-width:auto;display:inline-flex;align-items:center;justify-content:center;gap:8px;box-shadow:0 8px 18px #000a,0 0 0 0 var(--btn-ring);transition:transform .12s,box-shadow .12s,background .12s,opacity .12s;opacity:.35}
    body.ui-awake button{opacity:1} button:hover{background:var(--btn-bg-h);box-shadow:0 12px 26px #000c,0 0 0 6px var(--btn-ring)} button:active{background:var(--btn-bg-a);transform:translateY(1px)}
    .btn-loading{opacity:.9;pointer-events:none;position:relative}.btn-loading::after{content:"";position:absolute;inset:auto 6px 6px auto;width:14px;height:14px;border-radius:50%;border:2px solid #fff8;border-top-color:transparent;animation:spin .6s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}} .icon{width:16px;height:16px} .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
    #btnSound{min-width:auto;padding:6px 8px}
    #btnSound[data-muted="true"] .icon-sound-on{display:none} #btnSound[data-muted="true"] .icon-sound-off{display:inline}
    #btnSound[data-muted="false"] .icon-sound-on{display:inline} #btnSound[data-muted="false"] .icon-sound-off{display:none}
    #gatePlay{position:absolute;inset:0;z-index:9;display:flex;align-items:center;justify-content:center;background:linear-gradient(140deg,rgba(0,0,0,.55),rgba(0,0,0,.2));backdrop-filter:blur(2px)}
    #gatePlay.hidden{display:none}
    .gate-card{background:var(--panel-bg);border:1px solid var(--panel-bd);border-radius:18px;padding:18px 20px;display:flex;gap:12px;align-items:center;box-shadow:0 10px 40px rgba(0,0,0,.45)}
    .gate-card .icon{width:32px;height:32px;border-radius:50%;display:grid;place-items:center;border:1px solid var(--panel-bd);color:#fff;background:#111a;font-size:18px}
    #startBtn{min-width:160px}
    .swap-enter{opacity:0;transition:opacity .18s ease}.swap-enter.swap-enter-active{opacity:1}
    @media (orientation: landscape) and (max-width: 900px){#mainPreview{width:32%;height:30%;right:18px;top:14px;border-radius:18px}.hint{display:none}#camControls{top:50%;left:8px;bottom:auto;transform:translateY(-50%);flex-direction:column;align-items:stretch;padding:8px;gap:6px}#camControls button{min-width:86px;font-size:10px;padding:8px 10px;border-radius:10px}#globalControls{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 8px);left:50%;transform:translateX(-50%);min-width:260px}#scrub{width:220px}}
    @media (orientation: portrait){#mainPreview{top:12px;right:14px;width:58vw;height:36vh;border-radius:18px}#globalControls{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 8px);left:50%;transform:translateX(-50%);width:min(94vw,560px);padding:8px 10px;z-index:9999}#scrub{width:clamp(140px,56vw,380px)}#camControls{top:60px;left:6px;right:auto;bottom:auto;transform:none;display:flex;flex-direction:column;align-items:stretch;gap:6px;padding:8px 6px;max-height:58vh;overflow:auto;-webkit-overflow-scrolling:touch;background:linear-gradient(180deg,#0b0b0fb3,#0b0b0f99);border:1px solid var(--panel-bd);border-radius:14px;width:46px;transition:width .18s,box-shadow .18s;box-shadow:0 8px 24px rgba(0,0,0,.35);z-index:12}#camControls::-webkit-scrollbar{display:none}#camControls::before{content:"≡";display:block;text-align:center;color:#ffd6d6;opacity:.95;font-weight:800;font-size:10px;margin-bottom:6px;padding:4px 0;border-radius:10px;border:1px solid var(--panel-bd);background:#3a0c0caa}#camControls:hover,#camControls.expanded{width:150px}#camControls button{display:flex;align-items:center;justify-content:flex-start;gap:8px;border-radius:12px;padding:8px 10px;width:100%;font-size:10px;background:#1a1f2a;color:#fff;border:1px solid #ffffff1f;box-shadow:inset 0 0 0 1px #0003;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}#camControls:not(.expanded):not(:hover) button{padding:8px 6px}#camControls:not(.expanded):not(:hover) button span{display:none}#camControls button>span{display:inline}}
    #preloadBin{position:fixed;width:1px;height:1px;left:-9999px;top:-9999px;overflow:hidden;pointer-events:none;opacity:0}
  </style>
</head>
<body>
  <div id="playerContainer" aria-label="مشغّل متعدد الكاميرات">
    <canvas id="freezeLayer"></canvas>
    <div id="activeCam" class="videoFrame" aria-label="الكاميرا النشطة"></div>
    <div id="mainPreview" class="videoFrame" title="انقر للتكبير/التصغير" aria-label="المعاينة الرئيسية المصغّرة"></div>
    <div class="hint">انقر على المعاينة للتكبير • أو اضغط F</div>

    <!-- بوابة البدء -->
    <div id="gatePlay" role="dialog" aria-modal="true" aria-label="بدء التشغيل">
      <div class="gate-card">
        <div class="icon">▶</div>
        <div>
          <div style="color:#fff;font-weight:800;margin-bottom:6px">ابدأ التشغيل</div>
          <div style="font-size:12px;color:#eaeaf0b3">سيبدأ تشغيل الخط الرئيسي مع المزامنة • الصوت مكتوم افتراضيًا</div>
        </div>
        <button id="startBtn" aria-label="ابدأ التشغيل الآن">تشغيل/بدء المزامنة</button>
      </div>
    </div>

    <!-- أدوات -->
    <div id="utilityControls" class="vertical">
      <div class="group">
        <button id="btnSplit" aria-label="تبديل وضع التقسيم" title="تقسيم">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <rect x="3" y="4" width="18" height="16" rx="3"></rect><line x1="12" y1="4" x2="12" y2="20"></line>
          </svg><span class="sr-only">S</span>
        </button>
        <button id="btnFill" aria-label="تبديل تعبئة الفيديو" title="ملء المحتوى">
          <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3,10 3,3 10,3"></polyline><polyline points="21,14 21,21 14,21"></polyline>
            <line x1="3" y1="3" x2="10" y2="10"></line><line x1="21" y1="21" x2="14" y2="14"></line>
          </svg>
        </button>
      </div>
      <span class="divider"></span>
      <div class="group">
        <button id="btnSound" aria-label="تشغيل/إيقاف الصوت" data-muted="true" title="صوت">
          <svg class="icon-sound-on" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="green" stroke="green" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 10v4h4l5 4V6L7 10H3z"></path><path d="M14.5 8.5a4.5 4.5 0 0 1 0 6.4"/></svg>
          <svg class="icon-sound-off" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="red" stroke="red" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 10v4h4l5 4V6L7 10H3z"></path><path d="M16 8l4 4m0 0l-4 4"></path></svg>
          <span class="sr-only">M</span>
        </button>
      </div>
    </div>

    <!-- الشريط الموحّد -->
    <div id="globalControls" class="hidden" role="group" aria-label="تحكم موحّد">
      <button id="gBack" title="⏪ -5s">⏪ 5s</button>
      <button id="gPlay" title="⏯">⏯</button>
      <button id="gFwd"  title="+5s ⏩">5s ⏩</button>
      <input id="scrub" type="range" min="0" max="0" value="0" step="0.01" aria-label="شريط التقدم">
      <div id="timeLabel">00:00 / 00:00</div>
    </div>

    <!-- زر وضع الأداء الخفيف -->
    <button id="perfToggle" style="position:absolute; bottom:14px; right:14px; z-index:12;
      background:#263238; color:#fff; border:1px solid #ffffff26; padding:8px 10px; border-radius:10px; font-size:11px">
      وضع خفيف جدًا: مُفَعَّل
    </button>

    <!-- الكاميرات -->
    <div id="camControls" role="toolbar" aria-label="اختيار الكاميرات">
      <button data-cam="cam1"><span>Cam1</span></button>
      <button data-cam="cam2"><span>Cam2</span></button>
      <button data-cam="cam3"><span>Cam3</span></button>
      <button data-cam="cam4"><span>Cam4</span></button>
      <button data-cam="cam5"><span>Cam5</span></button>
      <button data-cam="cam6"><span>Drone</span></button>
      <button data-cam="cam7"><span>Sineflex</span></button>
    </div>
  </div>

  <!-- التسخين خارج الشاشة -->
  <div id="preloadBin" aria-hidden="true"></div>

  <!-- مصادر البث -->
  <script>
    window.sources = {
      main:  "https://stream.mux.com/jIy7RfNkNJqkZ1008eyc01WH9i4Nh37Q001xqZEdA50000LI.m3u8",
      cam1:  "",
      cam2:  "https://stream.mux.com/pp5DAu5IEgXKGPYByNtH23eb3q7wQrCKjWZYQ02h02Rnc.m3u8",
      cam3:  "",
      cam4:  "https://stream.mux.com/lQPRUXI5ej9dYmgBSy8YYZ6q7H9Rz2hquw8hWULlefA.m3u8",
      cam5:  "",
      cam6:  "https://stream.mux.com/KjaW9wNOl8XKUE3c3xB2aa502gqRnUHmaA3faW7U6nc00.m3u8",
      cam7:  "https://stream.mux.com/01ouHRNKSr8StdRxutJ9vay3yoMin00ia004k01KFXqdFJc.m3u8",
    };
  </script>

  <script>
    const hasUrl = (u)=> typeof u==='string' && /^https?:\/\/.+/.test(u);

    /* وضع خفيف جدًا — مفعل افتراضيًا */
    let performanceLightMode = true;
    function levelCapFor(isMirror=false){ return 360; } // سقف 360p للجميع

    const downlinkMbps = (navigator.connection && navigator.connection.downlink) ? navigator.connection.downlink : 2.5;

    // ========= إعدادات HLS (مُقوّاة ضد التقطعات) =========
    const HLS_CONFIG_BASE = {
      lowLatencyMode: false,
      liveSyncDurationCount: 3,       // المزامنة على عدد المقاطع (أكثر ثباتًا)
      capLevelToPlayerSize: true,
      maxFragLookUpTolerance: 0.25,
      maxBufferHole: 1.0,             // سمح بفجوات صغيرة دون توقف
      maxSeekHole: 2.0,
      nudgeOffset: 0.20,              // دفعة أكبر لتجاوز التعليق
      nudgeMaxRetry: 6,
      enableWorker: true,
      progressive: false,             // يقلّل jitter على أجهزة أضعف
      abrEwmaDefaultEstimate: Math.max(500_000,Math.min(2_500_000,downlinkMbps*500_000)),
      abrMaxWithRealBitrate: true,
      fragLoadingMaxRetry: 6,
      manifestLoadingMaxRetry: 6,
      levelLoadingMaxRetry: 5,
      fragLoadingRetryDelay: 350,
      manifestLoadingRetryDelay: 500,
      levelLoadingRetryDelay: 500,
      fragLoadingTimeOut: 10000,
      manifestLoadingTimeOut: 8000,
      levelLoadingTimeOut: 8000,
      fpsDroppedMonitoringPeriod: 1000,
      fpsDroppedMonitoringThreshold: 0.15,
      xhrSetup:(xhr)=>{ try{xhr.withCredentials=false;}catch(e){} }
    };
    // بافر افتراضي كبير للرئيسي
    const HLS_CONFIG = { ...HLS_CONFIG_BASE, maxBufferLength: 28, backBufferLength: 50 };

    async function isCodecSupported(codec){
      if(navigator.mediaCapabilities?.decodingInfo){
        try{
          const info=await navigator.mediaCapabilities.decodingInfo({type:'file',video:{contentType:`video/mp4; codecs="${codec}"`,width:1920,height:1080,bitrate:3_000_000,framerate:30}});
          return !!info.supported;
        }catch(e){}
      }
      const v=document.createElement('video'); return !!v.canPlayType(`video/mp4; codecs="${codec}"`);
    }
    const SUPPORTS={avc:null,hevc:null};
    (async()=>{SUPPORTS.avc=await isCodecSupported('avc1.640028')||await isCodecSupported('avc1.4d401f')||await isCodecSupported('avc1.42E01E'); SUPPORTS.hevc=await isCodecSupported('hvc1.1.6.L93.B0')||await isCodecSupported('hev1.1.6.L93.B0');})();

    function pickPlayableLevel(levels){
      let i=levels.findIndex(l=>/avc1/i.test(l?.codecs||l?.codecsVideo||'')); if(i>=0 && SUPPORTS.avc) return i;
      i=levels.findIndex(l=>/(hvc1|hev1)/i.test(l?.codecs||l?.codecsVideo||'')); if(i>=0 && SUPPORTS.hevc) return i;
      return levels?.length?0:-1;
    }

    const SYNC={ main:{pdtOffset:null}, active:{pdtOffset:null} };

    function hasBufferedAround(video, pad = 0.08){
      try{ const t=video.currentTime||0, r=video.buffered; if(!r||!r.length) return false;
        for(let i=0;i<r.length;i++){ const s=r.start(i), e=r.end(i); if(t>=s-pad && t<=e+pad) return true; } }catch(e){}
      return false;
    }
    function findNextBufferedStart(video){
      try{ const t=video.currentTime||0, r=video.buffered; if(!r||!r.length) return null;
        for(let i=0;i<r.length;i++){ const s=r.start(i), e=r.end(i); if(t<s) return s+0.04; if(t>=s&&t<=e) return null; } }catch(e){}
      return null;
    }
    async function healGapIfNeeded(video){
      if(hasBufferedAround(video)) return false;
      const next=findNextBufferedStart(video); if(next==null) return false;
      try{ if('setCurrentTime' in video) await video.setCurrentTime(next).catch(()=>{}); else video.currentTime=next; await video.play().catch(()=>{}); return true; }catch(e){}
      return false;
    }

    // ========== منطق الاستشفاء + مراقِب التقطّع ==========
    function attachRecovery(hls, video, role){
      // ضبط المستوى + سقف الجودة
      hls.on(Hls.Events.MANIFEST_PARSED,(_,data)=>{ try{
        const idx=pickPlayableLevel(data?.levels||[]); if(idx>=0){ hls.startLevel=idx; hls.currentLevel=idx; hls.nextLevel=idx; }
        const isMirror=(role!=='main'); const capHeight=levelCapFor(isMirror);
        if (isFinite(capHeight)) {
          const levels=data.levels||[]; let capIndex=levels.findIndex(l => (l.height||0) >= capHeight);
          if (capIndex < 0) capIndex = levels.length - 1;
          hls.autoLevelCapping = Math.max(0, capIndex - 1);
        }
        if (isMirror) { hls.config.maxBufferLength = performanceLightMode ? 10 : 14; hls.config.backBufferLength = 12; }
        else { hls.config.maxBufferLength = performanceLightMode ? 24 : 28; hls.config.backBufferLength = performanceLightMode ? 36 : 50; }
        hls.capLevelToPlayerSize = true;
      }catch(e){} });

      // استخلاص PDT/sequence + شفاء الفجوات
      hls.on(Hls.Events.LEVEL_UPDATED,(_,data)=>{ if(data?.details?.live){ hls.latencyController?.computeLivePosition?.(); } healGapIfNeeded(video); });
      hls.on(Hls.Events.FRAG_CHANGED,(_,data)=>{ const pdtMs=data?.frag?.programDateTime; if(pdtMs){ const off=pdtMs/1000 - (video.currentTime||0); if(isFinite(off)) SYNC[role].pdtOffset = off; } });

      // مراقبة التقطعات المتكررة → خفّض المستوى مؤقتًا
      let stallCount = 0;
      function softenQuality() {
        try{
          const lvls = hls.levels||[];
          if(!lvls.length) return;
          const targetH = 240; // اخفّض إلى ~240p عند الأزمة
          let cap = lvls.findIndex(l => (l.height||0) >= targetH);
          if (cap < 0) cap = lvls.length-1;
          hls.autoLevelCapping = Math.max(0, cap - 1);
        }catch(e){}
      }

      hls.on(Hls.Events.ERROR,(_,err)=>{
        const d=err||{}; const isNet=d.type===Hls.ErrorTypes.NETWORK_ERROR;
        const details=String(d.details||'');
        if(isNet){
          stallCount++;
          try{ hls.stopLoad(); }catch(e){} try{ hls.startLoad(0); }catch(e){}
          if (stallCount >= 3) { softenQuality(); stallCount = 0; }
          healGapIfNeeded(video); return;
        }
        if (/(BUFFER_|FRAG_PARSING|DECODE|MANIFEST_INCOMPATIBLE_CODECS)/i.test(details)){
          stallCount++;
          try{ hls.immediateLevelSwitch && hls.immediateLevelSwitch(); }catch(e){}
          try{ hls.swapAudioCodec?.(); hls.recoverMediaError?.(); }catch(e){}
          if (stallCount >= 3) { softenQuality(); stallCount = 0; }
          healGapIfNeeded(video); return;
        }
        if (d.fatal){ try{ hls.recoverMediaError?.(); }catch(e){} }
      });

      // مراقبة waiting/stalled
      const onWaiting=()=>{ healGapIfNeeded(video); };
      video.addEventListener('waiting', onWaiting); video.addEventListener('stalled', onWaiting);

      // حلقة مراقبة خفيفة
      let lastT=0, still=0;
      const poll=()=>{ const t=video.currentTime||0;
        if(video.readyState>=2 && !video.paused){
          if(Math.abs(t-lastT)<0.02){ if(++still>=2){ still=0; healGapIfNeeded(video); } } else still=0;
          lastT=t;
        } };
      if('requestVideoFrameCallback' in HTMLVideoElement.prototype){
        const loop=()=>{ try{ poll(); video.requestVideoFrameCallback(loop);}catch(e){} }; try{ video.requestVideoFrameCallback(loop);}catch(e){ setInterval(poll,1500); }
      } else setInterval(poll,1500);
    }

    // ========== منسّق توقفات الـ MAIN ==========
    function attachMainStallCoordinator(mainVideo, camVideo){
      const freezeFrom = (video)=>{
        try{
          const root=document.getElementById('playerContainer');
          const freezeLayer=document.getElementById('freezeLayer');
          const w=root.clientWidth,h=root.clientHeight; freezeLayer.width=w; freezeLayer.height=h;
          const ctx=freezeLayer.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);
          const rect=(video.getBoundingClientRect && video.parentElement)?video.parentElement.getBoundingClientRect():{width:w,height:h,left:0,top:0};
          const scaleX=w/rect.width, scaleY=h/rect.height; ctx.save(); ctx.scale(scaleX,scaleY); ctx.drawImage(video,0,0,rect.width,rect.height); ctx.restore(); freezeLayer.style.opacity='1';
        }catch(e){}
      };
      const unfreeze = ()=>{ document.getElementById('freezeLayer').style.opacity='0'; };

      const onStall = ()=>{ freezeFrom(mainVideo); try{ camVideo?.pause?.(); }catch(e){} };
      const onResume = async ()=>{
        unfreeze();
        try{ await camVideo?.play?.(); }catch(e){}
        // أعِدْ الضبط: اجعل الكاميرا تلحق الـ main بدقّة
        try{
          const mt = await getMainTime();
          await seekActiveTo(pdtAlignedTarget(mt));
        }catch(e){}
      };
      ['waiting','stalled','suspend','emptied','seeking'].forEach(ev=> mainVideo.addEventListener(ev,onStall));
      ['playing','canplay','canplaythrough','seeked'].forEach(ev=> mainVideo.addEventListener(ev,onResume));
    }

    /* DOM refs */
    const root=document.getElementById('playerContainer');
    const mainContainer=document.getElementById('mainPreview');
    const camContainer=document.getElementById('activeCam');
    const gatePlay=document.getElementById('gatePlay');
    const startBtn=document.getElementById('startBtn');
    const camControls=document.getElementById('camControls');
    const btnSplit=document.getElementById('btnSplit');
    const btnFill=document.getElementById('btnFill');
    const btnSound=document.getElementById('btnSound');
    const globalControls=document.getElementById('globalControls');
    const gPlay=document.getElementById('gPlay');
    const gBack=document.getElementById('gBack');
    const gFwd=document.getElementById('gFwd');
    const scrub=document.getElementById('scrub');
    const timeLabel=document.getElementById('timeLabel');
    const preloadBin=document.getElementById('preloadBin');
    const utilityControls=document.getElementById('utilityControls');
    const freezeLayer=document.getElementById('freezeLayer');
    const perfToggle=document.getElementById('perfToggle');

    let mainPlayer, activePlayer, currentCam="cam2";
    let splitMode=0, isMainFull=false, fillMode=false, started=false, inited=false;

    function reflectPerf(){ perfToggle.textContent = 'وضع خفيف جدًا: ' + (performanceLightMode ? 'مُفَعَّل' : 'متوقف'); }
    perfToggle.addEventListener('click', ()=>{ performanceLightMode=!performanceLightMode; reflectPerf(); SYNC_MGR?.ensureHiddenMirrors?.(); });
    reflectPerf();

    function clampToSeekable(video,t){
      const r=video.seekable; if(!r||!r.length) return t;
      const start=r.start(r.length-1), end=r.end(r.length-1);
      return Math.min(Math.max(t, start+0.05), end-0.05);
    }
    function pdtAlignedTarget(mainCt){
      const offM = SYNC.main.pdtOffset, offA = SYNC.active.pdtOffset;
      if(offM!=null && offA!=null) return (offM + (mainCt||0)) - offA;
      return mainCt;
    }

    function freezeFrom(video){
      try{
        const w=root.clientWidth,h=root.clientHeight; freezeLayer.width=w; freezeLayer.height=h;
        const ctx=freezeLayer.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,w,h);
        const rect=(video.getBoundingClientRect && video.parentElement)?video.parentElement.getBoundingClientRect():{width:w,height:h,left:0,top:0};
        const scaleX=w/rect.width, scaleY=h/rect.height; ctx.save(); ctx.scale(scaleX,scaleY); ctx.drawImage(video,0,0,rect.width,rect.height); ctx.restore(); freezeLayer.style.opacity='1';
      }catch(e){}
    }
    function unfreeze(){ freezeLayer.style.opacity='0'; }

    function createVideo(container, url, role){
      const wrapper=document.createElement('div'); wrapper.style.position='absolute'; wrapper.style.inset='0'; wrapper.className='swap-enter';
      container.appendChild(wrapper); requestAnimationFrame(()=>wrapper.classList.add('swap-enter-active'));

      const video=document.createElement('video');
      video.autoplay=false; video.playsInline=true; video.controls=false; video.muted=true; video.preload='auto'; video.crossOrigin='anonymous';
      video.style.width='100%'; video.style.height='100%'; video.style.objectFit=((splitMode===2||fillMode)?'cover':'contain');
      wrapper.appendChild(video);

      if (!hasUrl(url)) { console.warn('No valid URL for role:', role); return video; }

      const useHlsJs=()=> (window.Hls && Hls.isSupported());

      if(/\.m3u8(\?|$)/i.test(url)){
        if(video.canPlayType('application/vnd.apple.mpegURL')){
          video.src=url;
        }else if(useHlsJs()){
          const cfg={...HLS_CONFIG}; const hls=new Hls(cfg); video.__hls=hls; hls.attachMedia(video);
          hls.on(Hls.Events.MANIFEST_PARSED,(_,data)=>{
            const idx=pickPlayableLevel(data?.levels||[]); if(idx>=0){ hls.startLevel=idx; hls.currentLevel=idx; hls.nextLevel=idx; }
            const isMirror=(role!=='main'); const capHeight=levelCapFor(isMirror);
            if (isFinite(capHeight)) {
              const levels=data.levels||[]; let capIndex=levels.findIndex(l => (l.height||0) >= capHeight);
              if (capIndex < 0) capIndex = levels.length - 1;
              hls.autoLevelCapping = Math.max(0, capIndex - 1);
            }
          });
          hls.loadSource(url);
          attachRecovery(hls, video, role);
        }else{
          video.src=url;
        }
      }else if(/\.mpd(\?|$)/i.test(url) && window.dashjs){
        const p=dashjs.MediaPlayer().create(); p.initialize(video,url,false);
      }else{
        video.src=url;
      }

      video.addEventListener('loadedmetadata', ()=>{ video.play().catch(()=>{}); }, {once:true});
      video.addEventListener('canplay', ()=>{
        [...container.children].slice(0,-1).forEach(ch=>{ try{ const v=ch.querySelector?.('video'); v?.pause?.(); v?.__hls?.destroy?.(); ch.remove(); }catch(e){} });
        unfreeze();
      }, {once:true});
      return video;
    }

    function destroyVideoNode(node){
      if(!node) return;
      try{ const v=node.tagName==='VIDEO'?node:node.querySelector?.('video'); v?.pause?.(); v?.__hls?.destroy?.(); v?.removeAttribute?.('src'); v?.load?.(); }catch(e){}
      try{ node.remove(); }catch(e){}
    }

    function positionUtilityDock(){
      if(root.classList.contains('main-full')){ utilityControls.style.display='none'; return; }
      utilityControls.style.display='flex';
      const m=10, r=mainContainer.getBoundingClientRect();
      if(splitMode===0){
        utilityControls.classList.add('vertical'); utilityControls.classList.remove('horizontal');
        requestAnimationFrame(()=>{
          const cr=utilityControls.getBoundingClientRect();
          let left=r.left-cr.width-m; if(left<m) left=m;
          let top=r.top+(r.height-cr.height)/2; top=Math.max(m, Math.min(top, window.innerHeight-cr.height-m));
          utilityControls.style.left=left+'px'; utilityControls.style.right='auto'; utilityControls.style.top=top+'px';
        });
      }else{
        utilityControls.classList.remove('vertical'); utilityControls.classList.add('horizontal');
        utilityControls.style.top='10px'; utilityControls.style.right='10px'; utilityControls.style.left='auto';
      }
    }
    window.addEventListener('resize', positionUtilityDock);
    window.addEventListener('orientationchange', ()=>setTimeout(positionUtilityDock,120));

    function applySplitClasses(){
      root.classList.toggle('split',splitMode!==0);
      root.classList.toggle('fill',(splitMode!==0&&(splitMode===2||fillMode)));
      [mainContainer,camContainer].forEach(ct=>{ const v=ct.querySelector('video'); if(v){ v.style.objectFit=((splitMode===2||fillMode)?'cover':'contain'); } });
      positionUtilityDock();
    }
    function toggleSplitMode(){ splitMode=(splitMode+1)%3; if(splitMode!==0 && isMainFull){ isMainFull=false; root.classList.remove('main-full'); } applySplitClasses(); }
    function toggleFillMode(){ fillMode=!fillMode; applySplitClasses(); }
    function toggleMainZoom(){ if(splitMode!==0) return; isMainFull=!isMainFull; root.classList.toggle('main-full',isMainFull); positionUtilityDock(); }

    function initPlayers(){ if(!mainPlayer){ mainPlayer=createVideo(mainContainer, sources.main, 'main'); } activePlayer=createVideo(camContainer, sources[currentCam], 'active'); }

    async function playEntity(ent, muted=true){ try{ ent.muted=!!muted; await ent.play(); }catch(e){} }
    async function startPlayback(){
      if(started) return;
      started=true; gatePlay.classList.add('hidden'); globalControls.classList.remove('hidden');
      await playEntity(mainPlayer,true); await playEntity(activePlayer,true);
      attachMainStallCoordinator(mainContainer.querySelector('video'), camContainer.querySelector('video'));
      setTimeout(syncCams,220); positionUtilityDock(); startTimeTicker(); reflectSoundState();
    }

    function getMainTime(){ if(mainPlayer?.getCurrentTime) return mainPlayer.getCurrentTime(); return Promise.resolve(mainPlayer?.currentTime||0); }
    function getMainDuration(){
      if(mainPlayer?.getDuration) return mainPlayer.getDuration();
      if(mainPlayer instanceof HTMLVideoElement){
        const d=mainPlayer.duration; if(isFinite(d)) return Promise.resolve(d||0);
        const r=mainPlayer.seekable; if(r&&r.length) return Promise.resolve(r.end(r.length-1)||0);
      }
      return Promise.resolve(0);
    }
    function seekMainTo(t){ if(mainPlayer?.setCurrentTime) return mainPlayer.setCurrentTime(t).catch(()=>{}); if(mainPlayer?.seekTo){ try{mainPlayer.seekTo(t,true);}catch(e){} return Promise.resolve(); } if(mainPlayer instanceof HTMLVideoElement){ mainPlayer.currentTime=clampToSeekable(mainPlayer,t);} return Promise.resolve(); }
    function seekActiveTo(t){ if(activePlayer?.setCurrentTime) return activePlayer.setCurrentTime(t).catch(()=>{}); if(activePlayer?.seekTo){ try{activePlayer.seekTo(t,true);}catch(e){} return Promise.resolve(); } if(activePlayer instanceof HTMLVideoElement){ activePlayer.currentTime=clampToSeekable(activePlayer,t);} return Promise.resolve(); }
    async function syncCams(){ const t=await getMainTime(); const target=pdtAlignedTarget(t); await seekActiveTo(target); }

    function fmt(t){ t=Math.max(0,Math.floor(t||0)); const m=String(Math.floor(t/60)).padStart(2,'0'); const s=String(t%60).padStart(2,'0'); return `${m}:${s}`; }
    let ticker=null,isScrubbing=false;
    function startTimeTicker(){ if(ticker) return; ticker=setInterval(async()=>{ if(isScrubbing) return; const ct=await getMainTime(); let d=await getMainDuration(); if(mainPlayer instanceof HTMLVideoElement){ const r=mainPlayer.seekable; if(r&&r.length){ d=r.end(r.length-1)||d; } } if(d&&isFinite(d)) scrub.max=d; scrub.value=ct||0; timeLabel.textContent=`${fmt(ct)} / ${fmt(d||0)}`; },250); }

    async function reflectSoundState(){
      let muted=true;
      try{
        if(/vimeo\.com/i.test(sources.main) && mainPlayer?.getVolume){ const v=await mainPlayer.getVolume(); muted=(v===0); }
        else if(/youtube\.com|youtu\.be/i.test(sources.main) && mainPlayer?.isMuted){ muted=!!mainPlayer.isMuted(); }
        else if(mainPlayer instanceof HTMLVideoElement){ muted=!!mainPlayer.muted; }
      }catch(e){}
      btnSound.dataset.muted=String(muted);
    }
    async function toggleSound(){
      if(!started) await startPlayback();
      if(/vimeo\.com/i.test(sources.main) && mainPlayer?.getVolume){ try{ const v=await mainPlayer.getVolume(); if(v>0){ await mainPlayer.setVolume(0);} else { await mainPlayer.setVolume(1); await mainPlayer.play().catch(()=>{});} }catch(e){} await reflectSoundState(); return; }
      if(/youtube\.com|youtu\.be/i.test(sources.main) && mainPlayer?.isMuted){ try{ if(mainPlayer.isMuted()) mainPlayer.unMute(); else mainPlayer.mute(); mainPlayer.playVideo?.(); }catch(e){} await reflectSoundState(); return; }
      if(mainPlayer instanceof HTMLVideoElement){ try{ if(mainPlayer.muted){ mainPlayer.muted=false; mainPlayer.volume=1; await mainPlayer.play().catch(()=>{});} else { mainPlayer.muted=true; } }catch(e){} await reflectSoundState(); }
    }

    async function togglePlayPause(){
      if(mainPlayer?.getPaused){ const p=await mainPlayer.getPaused().catch(()=>null); if(p===null) return; if(p){ await mainPlayer.play().catch(()=>{});} else { await mainPlayer.pause().catch(()=>{});} const mt=await getMainTime(); await seekActiveTo(pdtAlignedTarget(mt)); return; }
      if(mainPlayer?.getPlayerState){ const st=mainPlayer.getPlayerState(); if(st===1){ mainPlayer.pauseVideo?.(); } else { mainPlayer.playVideo?.(); } const mt=await getMainTime(); await seekActiveTo(pdtAlignedTarget(mt)); return; }
      if(mainPlayer instanceof HTMLVideoElement){ if(mainPlayer.paused){ await mainPlayer.play().catch(()=>{});} else { mainPlayer.pause(); } const mt=await getMainTime(); await seekActiveTo(pdtAlignedTarget(mt)); }
    }
    async function jumpBy(d){ const t=await getMainTime(); const dmax=await getMainDuration(); let nt=(t||0)+d; if(dmax&&isFinite(dmax)) nt=Math.min(Math.max(0,nt),dmax); await seekMainTo(nt); await seekActiveTo(pdtAlignedTarget(nt)); }

    function switchCam(cam, btn){
      if (!hasUrl(window.sources[cam])) return;
      currentCam=cam; if(btn){ btn.classList.add('btn-loading'); setTimeout(()=>btn.classList.remove('btn-loading'),1200); }
      const currentVid = camContainer.querySelector('video') || mainContainer.querySelector('video');
      if(currentVid) freezeFrom(currentVid);
      const newcomer=createVideo(camContainer, sources[cam], 'active');
      const promote=async()=>{ activePlayer=newcomer; await playEntity(activePlayer,true); const mt=await getMainTime(); await seekActiveTo(pdtAlignedTarget(mt)); SYNC_MGR?.ensureHiddenMirrors?.(); attachMainStallCoordinator(mainContainer.querySelector('video'), activePlayer); };
      if(newcomer instanceof HTMLVideoElement){ newcomer.addEventListener('canplay',promote,{once:true}); newcomer.play().catch(()=>{}); } else { promote(); }
    }

    startBtn.addEventListener('click', async()=>{ await startPlayback(); positionUtilityDock(); });
    btnSplit.addEventListener('click', ()=>{ toggleSplitMode(); positionUtilityDock(); });
    btnFill.addEventListener('click',  ()=>{ toggleFillMode();  positionUtilityDock(); });
    btnSound.addEventListener('click', toggleSound);
    mainContainer.addEventListener('click', ()=>{ if(splitMode===0){ toggleMainZoom(); positionUtilityDock(); }});
    gPlay.addEventListener('click', togglePlayPause);
    gBack.addEventListener('click', ()=>jumpBy(-5));
    gFwd .addEventListener('click', ()=>jumpBy(+5));
    scrub.addEventListener('input', ()=>{ isScrubbing=true; });
    scrub.addEventListener('change', async()=>{ const nt=parseFloat(scrub.value)||0; await seekMainTo(nt); await seekActiveTo(pdtAlignedTarget(nt)); isScrubbing=false; });
    camControls.addEventListener('click',(e)=>{ const b=e.target.closest('button[data-cam]'); if(!b) return; switchCam(b.getAttribute('data-cam'), b); });

    document.addEventListener('keydown',(e)=>{
      if(e.key===' '||e.key==='Enter'){ e.preventDefault(); startPlayback(); }
      if(e.key==='S'||e.key==='s'){ toggleSplitMode(); positionUtilityDock(); }
      if(e.key==='F'||e.key==='f'){ toggleMainZoom(); positionUtilityDock(); }
      if(e.key==='M'||e.key==='m'){ toggleSound(); }
    });

    function warmFetch(url){ if(!hasUrl(url)) return; try{ fetch(url, {mode:'no-cors', cache:'reload'}).catch(()=>{}); }catch(e){} }
    const warmList = Object.values(window.sources).filter(hasUrl);

    // --- initOnce (eager + warm) ---
    function initPlayersOnce(){
      if(inited) return; inited=true;
      if(!mainPlayer){ mainPlayer = createVideo(mainContainer, sources.main, 'main'); if(mainPlayer.__hls){ try{ mainPlayer.__hls.startLoad(0); }catch(e){} } setTimeout(()=>{ try{ mainPlayer.load?.(); }catch(e){} }, 600); }
      const ids = Object.keys(sources).filter(k=>k!=='main' && hasUrl(sources[k]));
      if(ids.length) currentCam = ids[0];
      document.querySelectorAll('#camControls [data-cam]').forEach(btn=>{
        const id=btn.getAttribute('data-cam');
        if(id!=='cam1' && !hasUrl(sources[id])) btn.style.display='none';
      });
      if(!activePlayer){ activePlayer = createVideo(camContainer, sources[currentCam], 'active'); if(activePlayer.__hls){ try{ activePlayer.__hls.startLoad(0); }catch(e){} } }
      setTimeout(()=>warmList.forEach(warmFetch), 120);
      positionUtilityDock();
    }

    window.onYouTubeIframeAPIReady=()=>{ initPlayersOnce(); };
    window.addEventListener('DOMContentLoaded',  ()=>{ initPlayersOnce(); });

    (function autoUi(){ let t=null; const wake=()=>{ document.body.classList.add('ui-awake'); clearTimeout(t); t=setTimeout(()=>document.body.classList.remove('ui-awake'), 1800); }; ['mousemove','touchstart','touchmove','keydown','click'].forEach(ev=>window.addEventListener(ev,wake,{passive:true})); wake();})();
  </script>

  <!-- ======== مدير المزامنة + مرآة واحدة فقط (كما هو مع مطاردة أدق) ======== -->
  <script>
  const STREAM_META = {};
  function trackHlsMeta(hls, roleId){
    STREAM_META[roleId] ??= { pdt:null, sn:null, targetDur:null };
    hls.on(Hls.Events.LEVEL_UPDATED,(_,data)=>{ try{ STREAM_META[roleId].targetDur = data?.details?.targetduration || STREAM_META[roleId].targetDur; }catch(e){} });
    hls.on(Hls.Events.FRAG_CHANGED,(_,data)=>{ try{ const frag=data?.frag; if(!frag) return; STREAM_META[roleId].sn = frag.sn ?? STREAM_META[roleId].sn; STREAM_META[roleId].pdt = (frag.programDateTime ? frag.programDateTime/1000 : STREAM_META[roleId].pdt); }catch(e){} });
  }

  class SyncManager {
    constructor(){ this.loop=null; this.hiddenPool={}; this.desiredRateResetTimers=new WeakMap(); this._activeTrackedFor={}; this._mainTracked=false; }
    computeTargetFor(camId, mainTime){
      const mainMeta=STREAM_META['main'], camMeta=STREAM_META[camId];
      if(mainMeta?.pdt!=null && camMeta?.pdt!=null){ const offset=(mainMeta.pdt-camMeta.pdt); return mainTime + offset; }
      if(mainMeta?.sn!=null && camMeta?.sn!=null && (camMeta.targetDur||mainMeta.targetDur)){ const td=camMeta.targetDur||mainMeta.targetDur||4; const snDiff=(mainMeta.sn-camMeta.sn); return mainTime + (snDiff*td); }
      return mainTime;
    }
    gentlyChase(video, delta){
      const ad=Math.abs(delta);
      // مطاردة أكثر حزمًا لتصفير الانزياح سريعًا بدون قفزات
      if(ad < 0.06){ this.setPlaybackRate(video,1); return; }
      if(ad < 0.25){ this.setPlaybackRate(video, (delta>0?0.985:1.015)); return; }
      if(ad < 0.60){ this.setPlaybackRate(video, (delta>0?0.95:1.05)); return; }
      this.setPlaybackRate(video, 1);
    }
    setPlaybackRate(video, rate){
      try{
        if(Math.abs((video.playbackRate||1)-rate)<0.005) return;
        video.playbackRate=rate;
        clearTimeout(this.desiredRateResetTimers.get(video));
        const t=setTimeout(()=>{ try{ video.playbackRate=1; }catch(e){} },1200);
        this.desiredRateResetTimers.set(video,t);
      }catch(e){}
    }
    async forceRealign(video, target){ await this.seekVideoTo(video, target); await healGapIfNeeded(video); }
    async seekVideoTo(video, target){
      try{
        const r=video.seekable; if(r&&r.length){ const start=r.start(r.length-1), end=r.end(r.length-1); target=Math.min(Math.max(target,start+0.05), end-0.05); }
        if('setCurrentTime' in video){ await video.setCurrentTime(target).catch(()=>{}); return; }
        video.currentTime=target;
      }catch(e){}
    }
    start(){
      if(this.loop) return;
      const tick=async()=>{
        try{
          if(!mainPlayer) return;
          const mainTime=await getMainTime();

          if(activePlayer){
            const camId=currentCam; const target=this.computeTargetFor(camId, mainTime);
            let delta=(activePlayer.currentTime||0)-target;
            if(!hasBufferedAround(activePlayer)) await healGapIfNeeded(activePlayer);
            if(Math.abs(delta)>1.00){ await this.forceRealign(activePlayer, target); } else { this.gentlyChase(activePlayer, delta); }
            if(hasBufferedAround(activePlayer)){ (this.hiddenPool[camId] ??= {}).lastOkTs = performance.now(); }
          }

          for(const camId of Object.keys(this.hiddenPool)){
            const node=this.hiddenPool[camId]; const v=node.video; if(!v) continue;
            const target=this.computeTargetFor(camId, mainTime);
            let d=(v.currentTime||0)-target;
            if(!hasBufferedAround(v)){
              const healed=await healGapIfNeeded(v);
              if(!healed){ const lastOk=node.lastOkTs||0; if(performance.now()-lastOk>4000){ try{ node.hls?.stopLoad?.(); node.hls?.destroy?.(); }catch(e){} delete this.hiddenPool[camId]; continue; } }
            } else { node.lastOkTs=performance.now(); }
            if(Math.abs(d)>1.25){ await this.forceRealign(v, target); } else { this.gentlyChase(v, d); }
          }
        }catch(e){}
        this.loop=requestAnimationFrame(tick);
      };
      this.loop=requestAnimationFrame(tick);
    }
    stop(){ if(this.loop){ cancelAnimationFrame(this.loop); this.loop=null; } }

    ensureHiddenMirrors(){
      const idsAll = Object.keys(sources).filter(k => k!=='main' && hasUrl(sources[k]));
      if (!idsAll.length) return;
      const ids = [currentCam || idsAll[0]];

      for (const id of Object.keys(this.hiddenPool)) {
        if (!ids.includes(id)) {
          try { this.hiddenPool[id].hls?.stopLoad?.(); this.hiddenPool[id].hls?.destroy?.(); } catch(e){}
          try { this.hiddenPool[id].video?.pause?.(); } catch(e){}
          delete this.hiddenPool[id];
        }
      }

      const id = ids[0];
      if (this.hiddenPool[id]) return;

      const wrap=document.createElement('div'); wrap.style.width='1px'; wrap.style.height='1px'; wrap.style.overflow='hidden';
      const v=document.createElement('video'); v.muted=true; v.playsInline=true; v.preload='auto'; v.style.width='1px'; v.style.height='1px';
      wrap.appendChild(v); preloadBin.appendChild(wrap);

      const cfg={...HLS_CONFIG_BASE};
      cfg.maxBufferLength = 10;
      cfg.backBufferLength = 10;

      const hls=(window.Hls && Hls.isSupported())? new Hls(cfg): null;
      if(hls){
        hls.attachMedia(v);
        hls.on(Hls.Events.MEDIA_ATTACHED,()=>{ hls.loadSource(sources[id]); trackHlsMeta(hls, id); });
        hls.on(Hls.Events.MANIFEST_PARSED,(_,data)=>{
          const levels=data.levels||[];
          let capIndex = levels.findIndex(l => (l.height||0) >= 360);
          if (capIndex < 0) capIndex = levels.length - 1;
          hls.autoLevelCapping = Math.max(0, capIndex - 1);
        });
      } else {
        v.src=sources[id];
      }
      v.addEventListener('loadedmetadata',()=>{ v.play().catch(()=>{}); },{once:true});
      this.hiddenPool[id]={ video:v, hls, lastOkTs: performance.now() };
    }

    tapMainActiveHls(){
      try{
        if(mainPlayer?.__hls && !this._mainTracked){ trackHlsMeta(mainPlayer.__hls,'main'); this._mainTracked=true; }
        if(activePlayer?.__hls && !this._activeTrackedFor[currentCam]){ trackHlsMeta(activePlayer.__hls,currentCam); this._activeTrackedFor[currentCam]=true; }
      }catch(e){}
    }
  }
  const SYNC_MGR=new SyncManager();

  const _startPlaybackOrig = startPlayback;
  startPlayback = async function(){ await _startPlaybackOrig(); SYNC_MGR.ensureHiddenMirrors(); SYNC_MGR.tapMainActiveHls(); SYNC_MGR.start(); };

  const _createVideoOrig = createVideo;
  createVideo = function(container, url, role){
    const video=_createVideoOrig(container, url, role);
    const timer=setInterval(()=>{ try{ if(video && video.__hls){ const roleId=(role==='main')?'main':currentCam; trackHlsMeta(video.__hls, roleId); SYNC_MGR.tapMainActiveHls(); clearInterval(timer);} }catch(e){} },120);
    setTimeout(()=>clearInterval(timer),4000);
    return video;
  };

  const _switchCamOrig = switchCam;
  switchCam = function(cam, btn){ _switchCamOrig(cam, btn); setTimeout(()=>{ SYNC_MGR.tapMainActiveHls(); SYNC_MGR.ensureHiddenMirrors(); },500); };

  const _seekMainToOrig = seekMainTo;
  seekMainTo = async function(t){
    await _seekMainToOrig(t);
    const mainTime=await getMainTime();
    const target=SYNC_MGR.computeTargetFor(currentCam, mainTime);
    await seekActiveTo(target);
    for(const camId of Object.keys(SYNC_MGR.hiddenPool)){
      const v=SYNC_MGR.hiddenPool[camId]?.video;
      if(v) await SYNC_MGR.seekVideoTo(v, SYNC_MGR.computeTargetFor(camId, mainTime));
    }
  };
</script>

<!-- ===== DEBUG OVERLAY (كما هو) ===== -->
<script>
(function(){
  const box = document.createElement('div');
  box.style.cssText = 'position:fixed;left:10px;bottom:10px;z-index:99999;background:#0b0b0fcc;color:#fff;padding:8px 10px;border:1px solid #ffffff26;border-radius:10px;font:12px/1.4 system-ui;min-width:240px';
  box.innerHTML = '<b>Diag</b> <span id="dg-net"></span><br>'
                + 'Main t=<span id="dg-mt">0</span>s • buf=<span id="dg-mbuf">0</span>s<br>'
                + 'Cam  t=<span id="dg-at">0</span>s • buf=<span id="dg-abuf">0</span>s<br>'
                + 'Δ(main-cam)=<span id="dg-dt">0</span>s<br>'
                + 'DroppedFrames=<span id="dg-drop">0</span>';
  document.body.appendChild(box);
  const dg = {
    net: box.querySelector('#dg-net'),
    mt:  box.querySelector('#dg-mt'),
    mb:  box.querySelector('#dg-mbuf'),
    at:  box.querySelector('#dg-at'),
    ab:  box.querySelector('#dg-abuf'),
    dt:  box.querySelector('#dg-dt'),
    dr:  box.querySelector('#dg-drop'),
  };

  function bufLen(v){
    try{
      const r=v.buffered; if(!r||!r.length) return 0;
      const t=v.currentTime||0;
      for(let i=0;i<r.length;i++){ const s=r.start(i), e=r.end(i); if(t>=s && t<=e) return Math.max(0, e - t); }
      return 0;
    }catch(e){return 0;}
  }
  function netStr(){ const c = navigator.connection; if(!c) return ''; return `(${(c.downlink||0).toFixed(1)}Mbps ${c.effectiveType||''})`; }

  setInterval(async ()=>{
    try{
      dg.net.textContent = netStr();
      const mt = await getMainTime();
      const mb = mainPlayer ? bufLen(mainPlayer) : 0;
      const at = (activePlayer?.currentTime)||0;
      const ab = activePlayer ? bufLen(activePlayer) : 0;

      dg.mt.textContent = (mt||0).toFixed(2);
      dg.mb.textContent = mb.toFixed(2);
      dg.at.textContent = (at||0).toFixed(2);
      dg.ab.textContent = ab.toFixed(2);
      dg.dt.textContent = ((mt||0)-(at||0)).toFixed(2);

      let drop = 0;
      try {
        const vs = (mainPlayer?.getVideoPlaybackQuality && mainPlayer.getVideoPlaybackQuality())
                || (mainPlayer?.webkitDroppedFrameCount!=null ? {droppedVideoFrames:mainPlayer.webkitDroppedFrameCount} : null);
        if(vs) drop = vs.droppedVideoFrames|0;
      } catch(e){}
      dg.dr.textContent = drop;
    }catch(e){}
  }, 500);
})();
</script>

</body>
</html>
